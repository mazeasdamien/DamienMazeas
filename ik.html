<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js UR16e Controller</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #structure-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 90vh;
            max-width: 400px;
            overflow-y: auto;
            z-index: 100;
        }
        #structure-panel button {
            margin-left: 10px;
            background-color: #555;
            border: 1px solid #888;
            color: white;
            border-radius: 3px;
            cursor: pointer;
        }
        .structure-item {
            cursor: pointer;
            padding: 2px;
            border-radius: 2px;
            transition: background-color 0.2s, color 0.2s;
        }
        .structure-item.selected {
            background-color: #eab308;
            color: black;
            font-weight: bold;
        }
        #footer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 1.5rem 0;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="structure-panel">
        <h3>Model Structure <button id="toggle-gizmos">Toggle Gizmos</button></h3>
        <div id="structure-output">Loading model...</div>
    </div>
    <footer id="footer">
        <p>&copy; 2025 Damien Mazeas | Designed & Developed by the Author</p>
    </footer>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import GUI from 'lil-gui';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 3);
        dirLight.position.set(5, 10, 7.5);
        scene.add(dirLight);
        const gridHelper = new THREE.GridHelper(50, 100, 0x888888, 0x444444);
        scene.add(gridHelper);

        const gui = new GUI();
        const jointControls = {};

        const jointConfigurations = {
            'Base':     { axis: 'y', name: 'Rotate Y' },
            'Shoulder': { axis: 'z', name: 'Rotate Z' },
            'Elbow':    { axis: 'z', name: 'Rotate Z' },
            'Wrist1':   { axis: 'z', name: 'Rotate Z' },
            'Wrist2':   { axis: 'y', name: 'Rotate Y' },
            'Wrist3':   { axis: 'z', name: 'Rotate Z' }
        };

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredObj = null;
        let selectedObj = null;
        let robotModel = null;
        const gizmos = [];
        const selectableGroups = [];

        let movableSphere;
        let transformControls;

        function createMovableSphere() {
            // --- UPDATED: Sphere size increased by 20x, color changed to pink ---
            const sphereGeometry = new THREE.SphereGeometry(0.15 * 10, 32, 32); 
            const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0xFF69B4, metalness: 0.8, roughness: 0.2 }); // Pink color
            movableSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            movableSphere.position.set(1.5, 1, 1.5);
            scene.add(movableSphere);

            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.attach(movableSphere);
            scene.add(transformControls);

            transformControls.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
            });

            const sphereFolder = gui.addFolder('Movable Sphere');
            sphereFolder.add(movableSphere.position, 'x', -5, 5, 0.1).name('Position X').listen();
            sphereFolder.add(movableSphere.position, 'y', 0, 5, 0.1).name('Position Y').listen();
            sphereFolder.add(movableSphere.position, 'z', -5, 5, 0.1).name('Position Z').listen();
            sphereFolder.add(movableSphere, 'visible').name('Visible');
        }

        function findSelectableGroup(object) {
            if (!object) return null;
            let current = object;
            while (current) {
                if (selectableGroups.includes(current)) {
                    return current;
                }
                current = current.parent;
            }
            return null;
        }
        
        function buildStructureHTML(object, indent = '') {
            const container = document.createElement('div');
            if (selectableGroups.includes(object)) {
                const div = document.createElement('div');
                div.classList.add('structure-item');
                div.dataset.uuid = object.uuid;
                div.innerHTML = `${indent} L ${object.name} <span style="color: #888;">(Group)</span>`;
                container.appendChild(div);
            }
            const childIndent = selectableGroups.includes(object) ? indent + '&nbsp; |' : indent;
            object.children.forEach(child => {
                const childElement = buildStructureHTML(child, childIndent);
                if (childElement) {
                    container.appendChild(childElement);
                }
            });
            return container.children.length > 0 ? container : null;
        }
        
        function applyHighlight(groupToHighlight, type) {
            if (!groupToHighlight) return;
            groupToHighlight.traverse((object) => {
                if (object.isMesh) {
                    const immediateSelectableParent = findSelectableGroup(object);
                    if (immediateSelectableParent === groupToHighlight) {
                        if (!object.userData.originalMaterial) {
                            object.userData.originalMaterial = object.material;
                        }
                        const highlightMaterial = Array.isArray(object.userData.originalMaterial) ? object.userData.originalMaterial.map(m => m.clone()) : object.userData.originalMaterial.clone();
                        const applyProps = (mat) => {
                            mat.transparent = true;
                            mat.opacity = 0.5;
                            const color = (type === 'hover') ? 0xff0000 : 0xffff00;
                            mat.color.setHex(color);
                        };
                        if (Array.isArray(highlightMaterial)) {
                            highlightMaterial.forEach(applyProps);
                        } else {
                            applyProps(highlightMaterial);
                        }
                        object.material = highlightMaterial;
                    }
                }
            });
        }

        function clearHighlight(groupToClear) {
            if (!groupToClear) return;
            groupToClear.traverse((object) => {
                if (object.isMesh && object.userData.originalMaterial) {
                    const immediateSelectableParent = findSelectableGroup(object);
                    if (immediateSelectableParent === groupToClear) {
                        object.material = object.userData.originalMaterial;
                        object.userData.originalMaterial = null;
                    }
                }
            });
        }

        function selectObject(group) {
            if (selectedObj) {
                clearHighlight(selectedObj);
                const oldElem = document.querySelector(`.structure-item[data-uuid="${selectedObj.uuid}"]`);
                if (oldElem) oldElem.classList.remove('selected');
            }
            selectedObj = group;
            if (selectedObj) {
                applyHighlight(selectedObj, 'select');
                const newElem = document.querySelector(`.structure-item[data-uuid="${selectedObj.uuid}"]`);
                if (newElem) newElem.classList.add('selected');
            }
        }
        
        function hoverObject(group) {
            if (hoveredObj && hoveredObj !== selectedObj) {
                clearHighlight(hoveredObj);
            }
            hoveredObj = group;
            if (hoveredObj && hoveredObj !== selectedObj) {
                applyHighlight(hoveredObj, 'hover');
            }
        }

        const loader = new GLTFLoader();
        loader.load('3dmodels/UR16e.glb', (gltf) => {
            robotModel = gltf.scene; 
            scene.add(robotModel);

            robotModel.traverse((object) => {
                if(object.isGroup && object.name && object.children.some(c => c.isMesh)) {
                    selectableGroups.push(object);
                }
            });

            selectableGroups.forEach(group => {
                const config = jointConfigurations[group.name];
                if (config) {
                    jointControls[group.name] = 0;
                    gui.add(jointControls, group.name, -180, 180).name(`${group.name} ${config.name}`);
                }
            });

            const box = new THREE.Box3().setFromObject(robotModel);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            controls.target.copy(center);
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraDistance = Math.abs(maxDim / Math.sin(fov / 2));
            cameraDistance *= 1.5; 
            
            camera.position.copy(center);
            camera.position.x += cameraDistance / 2;
            camera.position.y += cameraDistance / 4;
            camera.position.z += cameraDistance;
            camera.lookAt(center);
            controls.update();

            const structureOutput = document.getElementById('structure-output');
            structureOutput.innerHTML = ''; 
            const structureElement = buildStructureHTML(robotModel);
            if(structureElement) {
                structureOutput.appendChild(structureElement);
            }
            
            selectableGroups.forEach(group => {
                const axesHelper = new THREE.AxesHelper(0.2); 
                group.add(axesHelper);
                gizmos.push(axesHelper);
            });

        }, undefined, (error) => {
            console.error('An error happened', error);
            document.getElementById('structure-output').innerText = 'Error loading model.';
        });

        createMovableSphere();

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            if (!robotModel) return;
            raycaster.setFromCamera(mouse, camera);
            
            if(transformControls && transformControls.dragging) return;

            const intersects = raycaster.intersectObject(robotModel, true);
            const firstIntersectedMesh = intersects.find(intersect => intersect.object.isMesh);
            const groupToHover = findSelectableGroup(firstIntersectedMesh?.object);
            hoverObject(groupToHover);
        }

        function onMouseClick(event) {
            if (event.button !== 0 || event.target.closest('#structure-panel') || event.target.closest('.lil-gui') || (transformControls && transformControls.dragging)) return; 
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(robotModel, true);
            const firstIntersectedMesh = intersects.find(intersect => intersect.object.isMesh);
            const groupToSelect = findSelectableGroup(firstIntersectedMesh?.object);
            selectObject(groupToSelect);
        }
        
        document.getElementById('structure-panel').addEventListener('click', (event) => {
            const item = event.target.closest('.structure-item');
            if(item && item.dataset.uuid) {
                const group = scene.getObjectByProperty('uuid', item.dataset.uuid);
                if(group) selectObject(group);
            }
        });

        document.getElementById('toggle-gizmos').addEventListener('click', () => {
            gizmos.forEach(gizmo => { gizmo.visible = !gizmo.visible; });
        });

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);

        function animate() {
            requestAnimationFrame(animate);

            if (robotModel && selectableGroups.length > 0) {
                selectableGroups.forEach(group => {
                    const config = jointConfigurations[group.name];
                    if (config) {
                        const value = jointControls[group.name];
                        group.rotation[config.axis] = THREE.MathUtils.degToRad(value);
                    }
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>