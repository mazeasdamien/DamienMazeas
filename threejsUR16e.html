<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UR16e controller - DM</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #444850 0%, #2a2d32 100%);
            font-family: monospace;
        }
        canvas { display: block; }
        #footer { position: absolute; bottom: 0; left: 0; width: 100%; padding: 1.5rem 0; text-align: center; color: rgba(255, 255, 255, 0.7); font-size: 12px; z-index: 100; pointer-events: none; }
        #control-panel {
            position: absolute; top: 15px; right: 15px; width: 300px;
            background: rgba(25, 25, 25, 0.85); backdrop-filter: blur(10px);
            border-radius: 8px; border: 1px solid rgba(128, 128, 128, 0.3);
            color: #f0f0f0; padding: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 101; user-select: none;
        }
        #panel-header {
            padding: 8px; cursor: move; background-color: rgba(80, 80, 80, 0.5);
            border-radius: 4px 4px 0 0; text-align: center; font-weight: bold;
            margin: -10px -10px 10px -10px;
        }
        .panel-section { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(128, 128, 128, 0.2); }
        .panel-section:last-child { border-bottom: none; }
        h4 { margin: 0 0 8px 0; color: #66d9ef; }
        .control-row, .readout-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; font-size: 12px; }
        .readout-row span:first-child { color: #a6e22e; }
        .readout-row span:last-child { color: #f92672; font-weight: bold; }
        label { flex-basis: 40%; }
        input[type="range"] { flex-grow: 1; -webkit-appearance: none; appearance: none; height: 4px; background: #444; outline: none; border-radius: 2px; margin-left: 10px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; background: #66d9ef; cursor: pointer; border-radius: 50%; }
        .slider-value { margin-left: 10px; min-width: 35px; text-align: right; color: #f92672; font-weight: bold; }
        .tabs { display: flex; border-bottom: 1px solid #555; margin-bottom: 10px; }
        .tab-button { flex: 1; padding: 8px; border: none; background: transparent; color: #aaa; cursor: pointer; font-family: monospace; border-bottom: 2px solid transparent; }
        .tab-button.active { color: #66d9ef; border-bottom: 2px solid #66d9ef; }
        .panel-button { width: 100%; padding: 8px; background: #555; border: 1px solid #777; color: white; border-radius: 4px; cursor: pointer; margin-top: 5px; }
        #error-overlay {
            display: none; position: absolute; top: 15px; left: 50%;
            transform: translateX(-50%); width: 80%; max-width: 800px;
            background: rgba(217, 0, 0, 0.85); color: white; padding: 15px;
            border-radius: 5px; text-align: center; z-index: 200;
            font-size: 14px; pointer-events: none;
        }
        #fps-counter {
            position: absolute; top: 10px; left: 10px; padding: 5px 10px;
            background: rgba(0,0,0,0.5); color: #a6e22e;
            border-radius: 3px; z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="error-overlay"></div>
    <div id="fps-counter">FPS: 0</div>
    <div id="control-panel">
        <div id="panel-header">ðŸ¤– UR16e Control Panel</div>
        <div class="panel-section">
             <button class="panel-button" id="toggle-mode-btn">Toggle Move/Rotate</button>
             <button class="panel-button" id="toggle-gizmos-btn">Toggle Joint Axes</button>
        </div>
        
        <div class="panel-section">
            <h4>Mode Select</h4>
            <div class="tabs">
                <button class="tab-button active" id="ik-mode-btn">Inverse Kinematics</button>
                <button class="tab-button" id="fk-mode-btn">Forward Kinematics</button>
            </div>
        </div>
        <div id="ik-controls">
            <div class="panel-section">
                <h4>IK Settings</h4>
                <div class="control-row">
                    <label for="solution-id-slider">Solution ID</label>
                    <input type="range" id="solution-id-slider" min="0" max="7" step="1" value="5">
                    <span class="slider-value" id="solution-id-value">5</span>
                </div>
            </div>
        </div>
        <div id="fk-controls" style="display: none;">
             <div class="panel-section">
                <h4>Forward Kinematics Control</h4>
             </div>
        </div>
        <div class="panel-section">
            <h4>Joint Angles (deg)</h4>
            <div id="joint-readouts"></div>
        </div>
    </div>
    <footer id="footer">
        <p>&copy; 2025 Damien Mazeas | Designed & Developed by the Author</p>
    </footer>

    <script type="importmap">
        { "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
        } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
        import IK_toolkit from './js/IK_toolkit.js';

        // --- Global Variables ---
        const errorOverlay = document.getElementById('error-overlay');
        function showError(message) { errorOverlay.textContent = `âš ï¸ Error: ${message}`; errorOverlay.style.display = 'block'; setTimeout(() => { errorOverlay.style.display = 'none'; }, 10000); }
        window.onerror = (message, source, lineno) => { showError(`${message} at ${source.split('/').pop()}:${lineno}`); };
        const originalConsoleError = console.error;
        console.error = function(message) { if (message instanceof Error) { showError(message.message); } else { showError(message); } originalConsoleError.apply(console, arguments); };

        let scene, camera, renderer, controls, ikToolkit, movableSphere, transformControls, dirLight;
        const controlSettings = { mode: 'ik', solutionID: 5, fk_angles: [0, 0, 0, 0, 0, 0] };
        const orderedJoints = [], gizmos = []; // gizmos will now hold the AxesHelpers
        const jointNames = ['Base', 'Shoulder', 'Elbow', 'Wrist1', 'Wrist2', 'Wrist3'];
        
        let lastTime = performance.now();
        let frameCount = 0;
        const fpsCounter = document.getElementById('fps-counter');

        // --- Initialization ---
        init();

        function init() {
            scene = new THREE.Scene();
            scene.name = "Scene";
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(2.5, 1.5, 2.5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setClearColor(0x000000, 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.18;
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0.8, 0);
            
            const exrLoader = new EXRLoader();
            exrLoader.load('./env/industrial_sunset_02_puresky_1k.exr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
            }, undefined, (error) => { console.error("Could not load EXR texture:", error) });
            
            dirLight = new THREE.DirectionalLight(0xffffff, 3);
            dirLight.position.set(5, 10, 7.5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            scene.add(dirLight);

            const gridHelper = new THREE.GridHelper(100, 100, 0x888888, 0x444444);
            gridHelper.receiveShadow = true;
            scene.add(gridHelper);

            // Add a larger AxesHelper at the world origin for reference
            const worldAxesHelper = new THREE.AxesHelper(1);
            scene.add(worldAxesHelper);

            ikToolkit = new IK_toolkit();
            loadModel();
            setupPanelControls();
            animate();
        }

        function loadModel() {
            const loader = new GLTFLoader();
            loader.load('3dmodels/UR16e.glb', (gltf) => {
                const root = gltf.scene;
                root.name = "UR_16e";
                scene.add(root);

                // Find and process all required parts
                root.traverse((object) => {
                    if (object.isMesh) { object.castShadow = true; }
                    if (object.name === 'IK_TARGET_CONTROL') { movableSphere = object; }
                    if (object.isGroup && jointNames.includes(object.name)) {
                        orderedJoints.push(object);
                    }
                });
                
                orderedJoints.sort((a, b) => jointNames.indexOf(a.name) - jointNames.indexOf(b.name));
                
                // âœ¨ DEBUG: Add an AxesHelper to each joint âœ¨
                if (orderedJoints.length === 6) {
                    orderedJoints.forEach(joint => {
                        const axesHelper = new THREE.AxesHelper(0.5); // Adjust size as needed
                        axesHelper.visible = false; // Initially hidden
                        joint.add(axesHelper);
                        gizmos.push(axesHelper); // Add to array to be toggled
                    });
                } else {
                    console.error("Could not find all 6 required robot joints.");
                }
                
                if (movableSphere) {
                    transformControls = new TransformControls(camera, renderer.domElement);
                    transformControls.attach(movableSphere);
                    transformControls.setSize(0.5);
                    scene.add(transformControls);
                    transformControls.addEventListener('dragging-changed', (event) => {
                        controls.enabled = !event.value;
                    });
                } else {
                    console.error("Could not find an object named 'IK_TARGET_CONTROL' in the GLB model.");
                }
                
                frameCamera(root);
            }, undefined, (error) => { console.error(error); });
        }
        
        function setupPanelControls() {
            const panel = document.getElementById('control-panel');
            const header = document.getElementById('panel-header');
            const ikModeBtn = document.getElementById('ik-mode-btn');
            const fkModeBtn = document.getElementById('fk-mode-btn');
            const solutionSlider = document.getElementById('solution-id-slider');
            const solutionIdValue = document.getElementById('solution-id-value');
            const toggleGizmosBtn = document.getElementById('toggle-gizmos-btn');
            const toggleModeBtn = document.getElementById('toggle-mode-btn');
            
            let isDragging = false, offset = { x: 0, y: 0 };
            header.addEventListener('mousedown', (e) => { isDragging = true; offset.x = e.clientX - panel.offsetLeft; offset.y = e.clientY - panel.offsetTop; });
            document.addEventListener('mouseup', () => { isDragging = false; });
            document.addEventListener('mousemove', (e) => { if (isDragging) { panel.style.left = `${e.clientX - offset.x}px`; panel.style.top = `${e.clientY - offset.y}px`; }});
            
            // This button now toggles the joint axes helpers
            toggleGizmosBtn.addEventListener('click', () => {
                if (gizmos.length > 0) {
                    const isVisible = !gizmos[0].visible;
                    gizmos.forEach(gizmo => gizmo.visible = isVisible);
                }
            });

            toggleModeBtn.addEventListener('click', () => { if (transformControls) { transformControls.setMode(transformControls.mode === 'translate' ? 'rotate' : 'translate'); }});
            
            ikModeBtn.addEventListener('click', () => setMode('ik'));
            fkModeBtn.addEventListener('click', () => setMode('fk'));
            
            function setMode(mode) {
                controlSettings.mode = mode;
                const ikControlsDiv = document.getElementById('ik-controls');
                const fkControlsDiv = document.getElementById('fk-controls');
                ikModeBtn.classList.toggle('active', mode === 'ik');
                fkModeBtn.classList.toggle('active', mode === 'fk');
                ikControlsDiv.style.display = mode === 'ik' ? 'block' : 'none';
                fkControlsDiv.style.display = mode === 'fk' ? 'block' : 'none';
                if (transformControls) { transformControls.enabled = (mode === 'ik'); transformControls.visible = (mode === 'ik'); }
            }

            solutionSlider.addEventListener('input', (e) => {
                controlSettings.solutionID = parseInt(e.target.value);
                solutionIdValue.textContent = e.target.value;
            });
            solutionIdValue.textContent = solutionSlider.value;

            const fkContainer = document.getElementById('fk-controls').querySelector('.panel-section');
            const readoutContainer = document.getElementById('joint-readouts');
            jointNames.forEach((name, i) => { const fkRow = document.createElement('div'); fkRow.className = 'control-row'; fkRow.innerHTML = `<label>${name}</label>`; const slider = document.createElement('input'); slider.type = 'range'; slider.min = -Math.PI; slider.max = Math.PI; slider.step = 0.01; slider.value = 0; slider.addEventListener('input', e => { controlSettings.fk_angles[i] = parseFloat(e.target.value); }); fkRow.appendChild(slider); fkContainer.appendChild(fkRow); const readoutRow = document.createElement('div'); readoutRow.className = 'readout-row'; readoutRow.innerHTML = `<span>${name}:</span> <span id="readout-j${i}">0.00</span>`; readoutContainer.appendChild(readoutRow); });
        }
        
        function solveIK() {
            if (!movableSphere || orderedJoints.length !== 6) return;

            // Step 1: Calculate the target matrix in the robot's local space.
            const robotBase = orderedJoints[0].parent; // The GLTF scene root for the robot
            robotBase.updateWorldMatrix(true, false);
            const inverseRobotBaseMatrix = new THREE.Matrix4().copy(robotBase.matrixWorld).invert();

            const targetWorldMatrix = movableSphere.matrixWorld.clone();

            // T_local = T_base_inverse * T_target_world
            const targetLocalMatrix = new THREE.Matrix4().multiplyMatrices(inverseRobotBaseMatrix, targetWorldMatrix);

            // Step 2: Replicate Unity's Y-axis reflection to match the C# solver's expectation.
            // The operation is M' = S * M * S, where S is the reflection matrix (its own inverse).
            const reflectionMatrix = new THREE.Matrix4().makeScale(1, -1, 1); // Reflects Y-axis
            const targetMatrixForIK = targetLocalMatrix.clone();

            // Perform M' = S * M * S
            targetMatrixForIK.premultiply(reflectionMatrix); // M' = S * M
            targetMatrixForIK.multiply(reflectionMatrix);   // M' = (S * M) * S


            // --- âš ï¸ DEBUG LOGS START âš ï¸ ---
            console.clear(); // Clear console to keep logs clean each frame
            console.log("--- IK DEBUG FRAME ---");
            // For clarity, let's log the final matrix being sent to the solver.
            console.log("Final Matrix for IK Solver:", targetMatrixForIK.elements);
            // --- âš ï¸ DEBUG LOGS END âš ï¸ ---

            const solutions = ikToolkit.inverseKinematicSolutions(targetMatrixForIK, movableSphere);
            
            // --- âš ï¸ DEBUG LOGS START âš ï¸ ---
            console.log("All 8 IK Solutions (Raw Output):", solutions);
            // --- âš ï¸ DEBUG LOGS END âš ï¸ ---

            const chosenSolution = solutions.map(row => row[controlSettings.solutionID]);
            
            // --- âš ï¸ DEBUG LOGS START âš ï¸ ---
            console.log(`Chosen Solution ID #${controlSettings.solutionID}:`, chosenSolution);
            // --- âš ï¸ DEBUG LOGS END âš ï¸ ---

            if (!chosenSolution.some(isNaN)) {
                applySolutionToJoints(chosenSolution);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            frameCount++;
            if (now >= lastTime + 1000) {
                fpsCounter.textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                lastTime = now;
            }

            if (orderedJoints.length === 6) {
                // âœ¨ IK is now solved every frame for real-time feedback âœ¨
                if (controlSettings.mode === 'ik' && movableSphere) {
                    solveIK();
                } else { // FK Mode
                    applySolutionToJoints(controlSettings.fk_angles);
                }
                updateReadouts();
            }
            controls.update();
            renderer.render(scene, camera);
        }
        
        function applySolutionToJoints(solution) {
            // This function maps the IK solution (in radians) to the specific
            // orientation of each joint in the Three.js scene.
            orderedJoints.forEach((joint, i) => {
                // For IK, the solution angle must be negated, as in the C# code.
                // For FK, we use the angle directly from the sliders.
                const angle = (controlSettings.mode === 'ik') ? -solution[i] : solution[i];

                let x = 0, y = 0, z = 0;

                // The main rotation from the solution is applied to the Y-axis.
                // This corresponds to the joint's primary axis of rotation in the GLB model.
                y = angle;

                // These static rotations on the X-axis orient the joints correctly.
                // They correspond to the C# code's offsets but with inverted signs
                // to account for the left-handed (Unity) vs. right-handed (Three.js) system.
                switch (i) {
                    case 1: // Shoulder
                        x = THREE.MathUtils.degToRad(90);
                        break;
                    case 4: // Wrist2
                        x = THREE.MathUtils.degToRad(90);
                        break;
                    case 5: // Wrist3
                        x = THREE.MathUtils.degToRad(-90);
                        break;
                }

                // Set the rotation using Euler angles. The default 'XYZ' order is correct.
                joint.rotation.set(x, y, z);
            });
        }
        
        function updateReadouts() {
            orderedJoints.forEach((joint, i) => {
                let angleRad = joint.rotation.y;
                if (controlSettings.mode === 'ik') angleRad *= -1;
                document.getElementById(`readout-j${i}`).textContent = THREE.MathUtils.radToDeg(angleRad).toFixed(2);
            });
        }
        
        function frameCamera(targetObject) {
             if(!targetObject) return;
             const box = new THREE.Box3().setFromObject(targetObject);
             const center = box.getCenter(new THREE.Vector3());
             controls.target.copy(center);
             const size = box.getSize(new THREE.Vector3());
             const maxDim = Math.max(size.x, size.y, size.z);
             const fov = camera.fov * (Math.PI / 180);
             const cameraDistance = Math.abs(maxDim / Math.sin(fov / 2)) * 1.5;
             camera.position.set(center.x + cameraDistance / 2, center.y + cameraDistance / 3, center.z + cameraDistance / 2);
             camera.lookAt(center);
        }
        
        window.addEventListener('resize', () => {
             camera.aspect=window.innerWidth / window.innerHeight;
             camera.updateProjectionMatrix();
             renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>